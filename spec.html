<!-- codepage utf-8 -->

<span style="color:#400;font-weight:8;">Текущая версия спецификации:</span>
<span style="color:#048;">0 (первый релиз будет 1 марта 2018 года)</span>

<h2> Что это за зверь </h2>

<p>Тралива - это JavaScript-фреймворк для декларативного программирования web-front-end-а и GUI для десктопных и мобильных приложений (максимум общего кода). Предполагается, что вы пишете код, который будет "скомпилирован", и файл <ww>traliva.js</ww> используется лишь как один из исходных файлов вашего проекта. Компиляция кода производится с помощью утилиты <a href="https://github.com/1024sparrow/compiler">compiler</a>. Это необязательное требование (чтобы компилировалось), но даёт возможности по минимизации кода, структурированию проекта, настраиваемости, а также позволяет избежать копирования кода. Когда буду писать учебные материалу на тему того, как писать программы посредством фреймворка Тралива, будет использоваться мой компилятор compiler.</p>


<h2>Оговорки</h2>
<p>В данном разделе приведены общие соображения по поводу того, куда ТРАЛИВА будет двигаться дальше, чего в спецификации фреймворка пока нет, и что хотелось бы добавить в следующей версии спецификации...</p>
<ul>
<li>Сейчас фреймворк ТРАЛИВА не включает в себя средств минимизации кода.</li>
<li>Логика строится посредством набора обработчиков единого объекта состояния, но нет механизма отладки и отслеживания последовательности изменений состояния (средства отладки есть, но, по-моему, можно инструментарий разработчика обеспечить и по-лучше).</li>
<li>Необходимо сделать проверку на соответвие кода спецификации на этапе сборки.</li>
<li>Писать логику для кроссплатформенного решения на JavaScript - это странно... Возможно, будет предложено логическую часть писать на C/C++ или <a href="https://ru.wikipedia.org/wiki/Rust_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">Rust</a>, которая для веба будет компилироваться в байт-код(см. <a href="https://ru.wikipedia.org/wiki/WebAssembly">WebAssembly</a>, <a href="http://asmjs.org/">asm.js</a>) </li>
</ul>

<h2>Как использовать</h2>

<figure>
&lt;html><br/>
&lt;head><br/>
&lt;meta name="viewport" content="width=device-width; user-scalable=0;" /><br/>
...<br/>
&lt;/head><br/>
...<br/>
&lt;body><br/>
...<br/>
&lt;noscript> Для работы сайта необходимо, чтобы поддержка JavaScript не была отключена.&lt;/noscript><br/>
&lt;script src="gameplay.js">&lt;/script><br/>
&lt;/body><br/>
&lt;/html>
</figure>
<p>Если вы скрипт <ww>traliva.js</ww> не вкомпилили в свой скрипт, то его необходимо подключить в секции HTML <ww>&lt;head></ww></p>

<p>Внутри gameplay.js делаем вызов</p>
<figure>
Traliva.init(o);
</figure>
<p>Функция <ww>Traliva.init()</ww> не предполагает множественного вызова. При повторном вызове этого метода в консоль должно быть выведено сообщение об ошибке.</p>

<h2> Формат объекта, передаваемого в функцию Traliva.init()</h2>

<p>Передаваемый в функцию Traliva.init() объект должен иметь следующие поля:</p>
<ul><li><ww>target</ww><br/>
идентификатор платформы. Например, для сайта здесь может быть 'web', а для мобильного приложения под Android - 'android'. Эта строка зашивается жёстко в код на этапе компиляции(написания) скрипта gameplay.js. Зачем этот идентификатор платформы оставлять в коде - для возможности быстрого переключения между разными версиями веб-приложения на этапе разработки.</li>
<li><ww>get_layout</ww></li>
<li><ww>layouts</ww></li>
<li><ww>widgets</ww></li>
<li><ww>states</ww></li>
<li><ww>extender</ww></li>
<li><ww>initApi</ww></li></ul>

<p>
В зависимости от размеров экрана или от платформы (предполагается, что помимо сайтов, фреймворк также используется для создания графических интерфейсов программ) элементы страницы располагаются тем или иным образом. Взаимное расположение элементов задаёт объект, который мы называем лэйаутом. Для разных платформ и разных размеров экрана (окна) могут применяться разные лэйауты. Объект, передаваемый параметром в <ww>Traliva.init()</ww> должен содержать свойства <ww>target</ww>(строковый идентификатор платформы - например, для сайта это может быть 'web', а для приложения под Android - 'android'), <ww>get_layout</ww>(функция, параметры - ширина w, высота h, идентификатор платформы target; возвращает идентификатор лэйаута) и <ww>layouts</ww> (объект, используемый как Map, в котором строковому идентификатору лэйаута ставится в соответствие лэйаут). Формат описания лэйаута приведён ниже (см. 'Формат лэйаута').
</p>
<figure>
Traliva.init({<br/>
<tab></tab>...<br/>
<tab></tab>target: 'web',<br/>
<tab></tab>get_layout: function(w,h,target){<br/>
<tab></tab><tab></tab>...<br/>
<tab></tab><tab></tab>return 'id лэйаута';<br/>
<tab></tab>},<br/>
<tab></tab>layouts: {<br/>
<tab></tab><tab></tab>'id лэйаута': {<br/>
<tab></tab><tab></tab><tab></tab>... лэйаут<br/>
<tab></tab><tab></tab>}<br/>
<tab></tab>},<br/>
<tab></tab>...<br/>
});
</figure>
В описании лэйаута могут упоминаться пользовательские виджеты (наследуются от класса <ww>Traliva.WidgetStateSubscriber</ww>) - в лэйауте указывается их строковый идентификатор (вы сами его задаёте), по которому функция <ww>Traliva.init()</ww> будет искать в свойстве <ww>widgets</ww> передаваемого параметром объекта. Свойство <ww>widgets</ww> представляет собой объект, в котором идентификаторам виджетов ставится в соответствие пара (т.е. массив) из функции-конструктора виджета и (опционально) строки/функции/объекта, определяющего подсостояние, с которым виджет работает (см. 'Формат определения подсостояний' ниже). Если подсостояние не задаётся, то можно передавать не пару (массив), а функцию-конструктор виджета.
<figure>
Traliva.init({<br/>
<tab></tab>...<br/>
<tab></tab>widgets: {<br/>
<tab></tab><tab></tab>'id виджета': [MyWidget, 'mySubstate/helloText'],<br/>
<tab></tab><tab></tab>'id другого виджета': MyWidget2<br/>
<tab></tab>},<br/>
<tab></tab>...<br/>
});
</figure>
<p>Для всего нашего веб-приложения определяется единый объект состояния (обычный JavaScript-объект). Все пользовательские виджеты наследуются от класса <ww>Traliva.WidgetStateSubscriber</ww>, и являются подписчиками изменений этого единого виджета состояния. Всевозможные компоненты загрузки, воспроизведения и т.д. осуществляются с помощью подписчиков на изменения состояния (отнаследуйтесь от класса <ww>Traliva.StateSubscriber</ww>), компоненты взаимодействуют друг с другом посредством единого объекта состояния.
Итак, нам для задания программы нужны</p>
<ol>
<li>Исходное состояние веб-приложения</li>
<li>Совокупность обработчиков-инициаторов изменений состояния</li>
<p>И, на самом деле, нам нужна ещё связь состояния веб-приложения с URL просматриваемой страницы. Если пользователь зашёл по сложному URL, мы должны соответствующим образом предоставить исходное состояние веб-приложения. И наоборот - если пользователь перешёл куда-то, что-то включил, он изменил состояние веб-приложения, которое должно отображаться по соответствующему URL, чтобы, когда пользователь сохранит ссылку на этот URL и позднее перейдёт по нему, он увидел то место, куда когда-то переходил, и нашёл то, что тогда включил, включенным. Так что добавляем третий пункт...</p>

<li>Связь состояния веб-приложения и URL</li>
</ol>

<p>Всё это определяется в свойстве <ww>states</ww> объекта, передаваемого параметром в функцию <ww>Traliva.init()</ww> - см. 'Формат объекта states' ниже.</p>
<figure>
Traliva.init({<br/>
<tab></tab>...<br/>
<tab></tab>states: {<br/>
<tab></tab><tab></tab>...<br/>
<tab></tab>},<br/>
<tab></tab>...<br/>
});
</figure>
<p>У нас пока получается так, что мы должны сразу создать все виджеты, которые у нас могут использоваться в текущем лэйауте, и во время работы веб-приложения только менять видимость созданных ранее виджетов.</p>
<p>Приведу пример. Пусть мы хотим в нашем веб-приложении разместить кнопку "Авторизоваться". Мы должны в лэйаут типа 'stack' положить виджеты всех диалоговых окон, которые нам потребуются во время авторизации (а у пользователя ведь может и не быть учётки, и надо будет регистрироваться...) - нельзя ли сделать динамическую подгрузку логики и GUI авторизации лишь по нажатию на пнопку "Авторизоваться"? Вот типичный случай, когда нам потребуется свойство <ww>extender</ww>(объект) - в нём мы указываем подсостояние, где Traliva должен мониторить значение строкового идентификатора A, и функцию, которая по значению A даёт лэйауты, виджеты и состояния. Как работать с <ww>extender</ww> описано ниже в разделе 'Подгрузка частей веб-приложения'.</p>

<p>Ну вот, осталось последнее свойство объекта, передаваемого параметром в функцию <ww>Traliva.init()</ww> - необязательное свойство <ww>initApi</ww>.</p>
<p>Если мы хотим, чтобы код нашего веб-приложения кроме того что работал в браузере пользователя, ещё и выступал как GUI для приложения под Android (или любую другую платформу), мы должны предоставить возможность веб-приложению "общаться" с неким API, который может представлять функционал, реализованный за пределами web-движка (нативный код). В случае запуска из браузера, API взаимодействия с "нативным кодом" будет представлен набором функций, написанных на JavaScript (возможно, заглушки). "Окно во внешний мир" - <ww>Traliva.api</ww> - подключать JavaScript-интерфейс взаимодействия с нативным кодом нужно сюда. Так вот, свойство <ww>initApi</ww> объекта, передаваеймого перематром в функцию <ww>Traliva.init()</ww> - это функция, принимающая параметром значение, указанное в свойстве <ww>target</ww>, и создающая все необходимые функции в объекте <ww>Traliva.api</ww>.</p>
<figure>
Traliva.init({<br/>
<tab></tab>...<br/>
<tab></tab>initApi: function(p_target){<br/>
<tab></tab>}<br/>
});
</figure>

<h2>Формат лэйаута</h2>

<p>Лэйаут представляет собой описание компоновки пользовательских виджетов (которые описываются отдельно в свойстве <ww>widgets</ww> объекта, передаваемого параметром в функцию <ww>Traliva.init()</ww>).</p>
<p>При компоновке используются контейнеры виджетов. Фреймворк Тралива содержит контейнеры виджетов двух типов:</p>
<ul>
<li><ww>strip</ww> - линейный контенер - либо элементы в столбец, либо в строку</li>
<li><ww>stack</ww> - многослойный контейнер - все элементы располагаются один поверх другого. Применим для тех областей, где одни виджеты должны сменить другие.</li>
</ul>
<p>Лэйаут - это JavaScript-объект, в который вложены другие объекты, в которые, в свою очередь, могут быть вложены свои объекты... Лэйаут обязательно должен иметь тип (свойство <ww>type</ww>): <ww>'strip'</ww>, <ww>'stack'</ww>, <ww>'widget'</ww> или <ww>'const_widget'</ww>.</p>
<subdiv>
<p>Элемент типа <ww>strip</ww> (линейный контейнер) должен иметь следующие свойства (помимо <ww>'type'</ww>):</p>
<ul>
<li><ww>orient</ww> - ориентация: может иметь значение <ww>'v'</ww>(дочерние элементы в столбец) или <ww>'h'</ww>(дочерние элементы в строку)</li>
<li><ww>items - массив объектов-обёрток над дочерними элементами.</ww></li>
</ul>
<p>Объект-обёртка дочернего элемента для линейного контейнера может имеьт два свойства:</p>
<ul>
<li><ww>size</ww>(необязательное свойство) - размер (тип строка). Поддерживаемые единицы измерения - <ww>'px'</ww>(пиксели) и <ww>'part'</ww>(часть от оставшегося после элементов с размерами в пикселях места). Например, '32px', '2 part'(с пробелом), '2part'. Если в контейнере подряд идут элементы с размерами '2part','32px' и '1part', то второй элемент будет иметь размер 32 пикселя, а первый и третий элементы поделят между собой оставшееся место в соотношении 2 к 1 соответственно. Значение по умолчанию - '1 part'.</li>
<li><ww>widget</ww>(необязательное свойство) - дочерний элемент</li>
</ul>
<p>Объект <ww>{}</ww>, переданный в качестве объекта-обёртки дочернего элемента, означает "пружинку".</p>
</subdiv>
<subdiv>
<p>Элемент типа <ww>stack</ww> (многослойный контейнер) должен иметь следующие свойства (помимо <ww>'type'</ww>):</p>
<ul>
<li><ww>items - массив дочерних элементов</ww></li>
</ul>
</subdiv>
<subdiv>
<p>Элемент типа <ww>widget</ww> - пользовательский виджет (который наследуется от <ww>Traliva.WidgetStateSubscriber</ww> и указывается в свойстве <ww>widgets</ww> объекта, передаваемого параметром функции <ww>Traliva.init()</ww>) - задаётся не объектом, а строкой - идентификатором виджета, по которому функция <ww>Traliva.init()</ww> будет искать в свойстве объекта, передаваемого параметром, <ww>widgets</ww>. Если же в поле <ww>widgets</ww> не найден соответвующий конструктор, будет создана заглушка - виджет, на котором отображается id_виджета и цвет фона имеет уникальное в рамках всего веб-приложения значения.</p>
</subdiv>
<subdiv>
<p>Элемент типа <ww>const_widget</ww> полностью аналогичен элементу типа <ww>widget</ww> с тем лишь исключением, что при динамической подгрузке контента (см. 'Подгрузка частей веб-приложения' ниже), при попытке подменить класс, представляюший данный виджет, в консоль будет выведено сообщение об ошибке и виджет не будет заменён.</p>
</subdiv>
<p>В случае, если контейнеры вам не нужны, и вы хотите видеть пользовательский виджет на всё окно, укажите идентификатор пользовательского виджета (тип строка) в качестве лэйаута.</p>
<p>Пример лэйаута:</p>
<figure>
Traliva.init({<br/>
<tab></tab>...<br/>
<tab></tab>layouts:{<br/>
<tab></tab><tab></tab>small:{<br/>
<tab></tab><tab></tab>},<br/>
<tab></tab><tab></tab>normal:{ // <-- вот он, лэйаут<br/>
<tab></tab><tab></tab><tab></tab>type: 'strip',<br/>
<tab></tab><tab></tab><tab></tab>orient: 'v',<br/>
<tab></tab><tab></tab><tab></tab>items:[<br/>
<tab></tab><tab></tab><tab></tab><tab></tab>{<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>widget:{<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>type: 'strip',<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>orient: 'h',<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>items:[<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>{<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>widget: 'header__bnCatalogue',<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>size: '128px'<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>},<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>{<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>widget: 'header__bnSaved',<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>size: '128px'<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>},<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>{}, // stretch<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>{<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>widget: 'header_right__bnAuth',<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>size: '64px'<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>}<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>]<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>},<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>size: '64px'<br/>
<tab></tab><tab></tab><tab></tab><tab></tab>},<br/>
<tab></tab><tab></tab><tab></tab><tab></tab>{//здесь контент будет меняться в зависимости от выбранной вкладки, занимать всё доступное место<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>widget:'main_scene'<br/>
<tab></tab><tab></tab><tab></tab><tab></tab>},<br/>
<tab></tab><tab></tab><tab></tab><tab></tab>{<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>// footer<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>widget: 'footer_stub',<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>size: '64px'<br/>
<tab></tab><tab></tab><tab></tab><tab></tab>}<br/>
<tab></tab><tab></tab><tab></tab>]<br/>
<tab></tab><tab></tab>},<br/>
<tab></tab><tab></tab>large:{<br/>
<tab></tab><tab></tab>}<br/>
<tab></tab>},<br/>
<tab></tab>...<br/>
});
</figure>

<h2>Формат объекта 'states'</h2>

<!-- Пример: https://traliva.ru/static/tab_apps/django/1.js -->
<p>Свойство <ww>states</ww> объекта, передаваемого функции <ww>Traliva.init()</ww>, описывает связь состояния веб-приложения и его сетевого адреса URL, задаёт исходное состояние веб-приложения (исходя из его URL), а также именно в нём указываются те обработчики-инициаторы изменений состояния, которые, собственно, определяют всю логику работы веб-приложения (наследуются от класса <ww>Traliva.StateSubscriber</ww>). Перечислим свойства объекта <ww>states</ww>:</p>
<ul>
<li><ww>initState</ww></li>
<li><ww>tree</ww></li>
<li><ww>initPath</ww></li>
<li><ww>stringifyState</ww></li>
<li><ww>_prev_values</ww></li>
<li><ww>stateSubscribers</ww></li>
</ul>

<p>
<ww>initState</ww> - объект, определяющий состояние веб-приложения в том случае, если пользователь зашёл на корневую страницу.<br/>
Если пользователь зашёл на некорневую страничку, состояние будет достраиваться исходя из этого исходного состояния
</p>
<subdiv>
<p> <ww>tree</ww> - дерево переходов между сетевыми адресами. URL имеет строго древовидную структуру, и в каждый момент времени пользователь находится на том или ином узле этого дерева.
В объекте, описывающем дерево переходов, мы создаём свойства с такими именами, какие у корневой страницы могут быть поддиректории (в представлении URL).
Например, если мы пишем сайт <ww>traliva.ru</ww>, мы прописываем у <ww>tree</ww> свойства <ww>download</ww> и <ww>documentation</ww>, и теперь у нас в дереве определены URL-ы <ww>traliva.ru/download/</ww> и <ww>traliva.ru/documentation/</ww>.
Также в объекте <ww>tree</ww> прописываем свойство <ww>_default</ww>(объект), пишем туда свойством <ww>processor</ww> функцию, которая будет инициализировать объект состояния веб-приложения при переходе на <ww>traliva.ru/</ww> (но не на <ww>traliva.ru/download/</ww>)
По очевидной, думаю, причине не следует использовать символ <ww>/</ww>  в именовании свойств объекта <ww>tree</ww>.
В созданных нами свойствах мы можем прописать следующие свойства: </p>
<ul>
<li><ww>children</ww></li>
<li><ww>in</ww></li>
<li><ww>out</ww></li>
<li><ww>params</ww></li>
<li><ww>change</ww></li>
</ul>

<p>Свойство <ww>children</ww> - дочерние элементы этого уза дерева URL-адресов. Например, если у нас по адресу <ww>traliva.ru/download/</ww> доступны три файла на скачивание, то у нас элемент <ww>download</ww> должен иметь три дочерних элемента: <ww>1.exe</ww>, <ww>2.exe</ww> и <ww>3.exe</ww>. Свойство <ww>children</ww> имеет тип объект - названия свойств этого объекта соответствуют дочерним элементам URL. У свойства <ww>children</ww> есть также специальное свойство - <ww>_default</ww> - этот объект описывает тот случай, когда детей нет. Как и для объекта <ww>tree</ww>, это свойство имеет свойство <ww>processor</ww> - функцию, которая вызывается при переходе на такой URL.
<p>Свойства <ww>in</ww> и <ww>out</ww> - функции, которые вызываются, когда URL входит и выходит в описываемую группу URL соответственно. Параметром принимают ссылку на объект состояния, и могут добавить/удалить свойства этого объекта. Например, когда пользователь переходит с URL <ww>traliva.ru/download/</ww> на URL <ww>traliva.ru/documentation/</ww>, в узле <ww>tree &#8594; download</ww> вызывается функция <ww>out</ww>, а затем в узле <ww>tree &#8594; documentation</ww> вызывется функция <ww>in</ww>. Насчёт <ww>_default</ww> и <ww>in</ww> - сначала вызывается <ww>in</ww> и лишь потом <ww>children._default.processor</ww>, если дочерних элементов нет. При более сложных URL - сначала с конца URL до наибольшей общей части с новым URL вызываются соответвующие функции <ww>out</ww>, затем от наибольшей общей части до конца нового URL вызываются соответствующие функции <ww>in</ww>, потом вызывается функция <ww>children._default.processor</ww> конечного элемента дерева (т.е. листа дерева, а не узла).</p>
<p>Если запрашиваемый URL не соответвует дереву переходов <ww>tree</ww>, состояние сбрасывается в дефолтное (которое определено в свойстве <ww>initState</ww>)</p>
<p>Свойство <ww>params</ww> - целое число, задаёт число параметров. Если число параметров отлично от нуля, то такое количество последующих поддиректорий URL трактуются как параметры. Эти параметры при (переходе на) или при (смене параметров) используются в качестве свойств объекта параметров, передаваемого в функцию <ww>change</ww>. Функция <ww>change</ww> вызывается при изменении/применении параметров, принимает три параметра: ссылку на объект состояния веб-приложения, предыдущий набор параметров, новый набор парамеров.</p>

</subdiv>

<p>Свойство <ww>initPath</ww> (тип строка) задаёт ту часть URL, начиная с имени домена, которую при анализе надо игнорировать, должно начинаться и оканчиваться на <ww>/</ww>. В большинстве случаев требуется значение <ww>/</ww> (от корня). Другие значения будут использоваться, если предполагается использование вашего сайта в <ww>&lt;iframe></ww> другого сайта. А ещё другие значения будут использоваться, когда будет динамическая подгрузка частей веб-приложения (см. 'Подгрузка частей веб-приложения' ниже).</p>
<p>Свойство <ww>stringifyState</ww> - функция, которая возвращает URL для текущего объекта состояния. Вот тут вам и пригодится свойство <ww>initPath</ww>, описанное ранее. Принимает два параметра: ссылку на объект состояния веб-приложения и ссылку на объект, свойство <ww>b</ww> которого содержит в себе флаг (тип boolean), значение <ww>true</ww> которого означает, что новый URL не будет добавлен в историю браузера, а заменит текущий.</p>
<p>Свойство <ww>_prev_values</ww> функцией <ww>Traliva.init()</ww> никак не используется - это свойство предлагается использовать разработчику для хранения предыдущих значений, для хранения данных между вызовами метода <ww>stringifyState</ww></p>
<p>Ну вот мы и подобрались к тому, что, собственно, и определяет поведение веб-приложения - набору подписчиков/инициаторов изменения состояния - свойству <ww>stateSubscribers</ww>. Это список конструкторов классов-наследников <ww>Traliva.StateSubscriber</ww> (подписчиков). Если нужно, чтобы класс подписчика выдел не всё состояние, а только какое-то его подсостояние, то вместо конструктора необходимо передать массив (<ww>[...]</ww>), состоящий из конструктора(первый элемент) и объекта, характеризующего подсостояние(второй элемент) - см. 'Формат описания подсостояний' ниже.</p>

<h2>Формат описания подсостояний</h2>
<p>Подсостояние - это часть объекта состояния. Подсостояние может быть представлено только объектом или массивом (строка или целое_число не могут использовыаться в качестве подсостояния - это связано с тем, что подсостояние должно передаваться по ссылке, а не по значению).</p>
<p>Для указания подсостояния есть два варианта формата на ваш выбор:</p>
<ul>
<li>строка. Напишите путь к подсостоянию от корня, использую символ <ww>/</ww> в качестве разделителя</li>
<li>функция. Напишите функцию, которая принимает один параметр - объект состояния, и возвращает нужное подсостояние</li>
</ul>

<h2>Подгрузка частей веб-приложения</h2>

<h2>Минимальный пример</h2>

<!--<h2>Низкоуровневые вещи</h2>
Три составляющие:
<ul>
<li>Классы для работы с состояниями. Паттерн "Подписчик-издатель" для изменений в едином объекте, описывающем состояние всего веб-приложения.</li>
    <ul>
    <li><ww>StatePublisher</ww> "Издатель" - экземпляр этого класса оповещает подписчиков об изменении Состояния.</li>
    <li><ww>StateSubscriber</ww> Класс для наследования. "Подписчик". Обрабатывает изменения Состояния и регистрирует свои изменения.</li>
    <li><ww>StateDebugWidget</ww> Подписчик, который в реальном времени отображает Состояние внутри указанного div-а (DomElement).</li>
    <li><ww>StateToUriMapper</ww> Подписчик, который отображает Состояние в URL и обратно - при смене URL соответвующим образом меняет объект Состояния. Конструктор параметром принимает объект, описывающий соответствие подкаталогов URL-а значениям отдельных полей в объекте Состояния.</li>
    </ul>
<li>Классы для построения GUI. События изменения размеров виджетов прокидываются сверху вниз - от браузера к виджету верхнего уровня, и далее к его дочерним виджетам. Также прокидываются события изменения видимости, и есть свой метод для переопределения onScrolled.</li>
    <ul>
    <li><ww>_WidgetBase</ww> Класс для наследования. Наследуйтесь от этого класса, если хотите написать свой контейнер виджетов. Под виджетом понимается наследник этого класса.</li>
    <li><ww>Widget</ww> Контейнер одного элемента, который можно передавать StateSubscriber-ам для установки ими туда другого виджета или DOM-элемента.</li>
    <li><ww>Strip</ww>  Контейнер виджетов: Горизонтальный или вертикальный лэйаут.</li>
    <li><ww>Stack</ww>  Контейнер виджетов: Многослойный.</li>
    </ul>
<li>Отдельные функции общего назначения</li>
    <ul>
    <li><ww>ajax</ww>  - обёртка над XmlHttpRequest для простого выполнения асихронных HTTP-запросов.</li>
    <li><ww>checkVisible </ww> - эта простенькая функция вам понадобится, если вы будете делать динамическую подгрузку контента при прокручивании контента.</li>
    </ul>
</ul>-->

<h2>Лицензия</h2>

<p>Copyright © 2017 <a href="https://github.com/1024sparrow">Васильев Борис</a><br/>
Публикуется под лицензией <a href="https://github.com/1024sparrow/traliva/blob/master/LICENSE">MIT license</a>.</p>
